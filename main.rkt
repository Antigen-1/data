#lang racket/base
(require (for-syntax racket/base) racket/splicing)
(provide (all-defined-out))

(define-syntax (define-data stx)
  (syntax-case stx (lib representation abstraction)
      ((_ name
          (lib primitive ...)
          (representation (rp-name rp-body) ...)
          (abstraction (ab-name ab-body) ...))
       (let ((add-nm (lambda (stx) ((make-interned-syntax-introducer (syntax->datum #'name)) stx 'add)))
             (add-rp (lambda (stx) ((make-interned-syntax-introducer 'representation) stx 'add)))
             (add-ab (lambda (stx) ((make-interned-syntax-introducer 'abstraction) stx 'add)))
             (make-id (lambda (str) (datum->syntax #'stx (string->symbol (format "~a:~a" (syntax->datum #'name) str))))))
         (with-syntax (((rp-name ...) (map (compose add-rp add-nm) (syntax->list #'(rp-name ...))))
                       ((rp-body ...) (map (compose add-rp add-nm) (syntax->list #'(rp-body ...))))
                       ((ab-name ...) (map (compose add-ab add-nm) (syntax->list #'(ab-name ...))))
                       ((ab-body ...) (map (compose add-ab add-rp add-nm) (syntax->list #'(ab-body ...)))))
           #`(begin
               (splicing-let () (local-require primitive ...) (define rp-name rp-body) ...)
               (splicing-let () (define ab-name ab-body) ...)
               (provide (for-space #f rp-name ... ab-name ...)
                        (for-space #,(make-id "representation") rp-name ...)
                        (for-space #,(make-id "abstraction") ab-name ...))
               ))))))
